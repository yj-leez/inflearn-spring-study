# 자바 ORM 표준 JPA 프로그래밍

## JPA 소개

- JPA: 자바 진영의 ORM 기술 표준
- ORM: 객체는 객체대로 설계하고 관계형 DB는 관계형 DB대로 설계할 수 있게끔 중간에서 객체와 DB의 관계를 매핑해주는 프레임워크
- JPA는 어플리케이션과 JDBC 사이에서 동작한다.
    <img width="699" alt="스크린샷 2023-06-24 오후 7 11 39" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/06723e50-e088-4c29-b5ee-45f3e5ee3caf">


    
- JPA의 성능 최적화 기능
    1. 1차 캐시와 동일성 보장 : 같은 트랜잭션 안에서는 같은 엔티티 반환
    2. 트랜잭션을 지원하는 쓰기 지연
        - INSERT: 트랜잭션을 커밋할 때까지 INSERT SQL을 모은 후 커밋하는 순간 한번에 SQL 전송
        - UPDATE: UPDATE, DELETE로 인한 로우락 시간 최소화위해 커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다.
    3. 지연 로딩(Lazy Loading) : 객체가 실제로 사용될 때 로딩

## JPA시작

- JPA 구동방식
    
<img width="820" alt="스크린샷 2023-06-24 오후 11 19 53" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/f17b5a15-c9ff-49e1-98f9-ee9a63f3fde8">

    

## 영속성 관리

### 영속성 컨텍스트

- 영속성 컨텍스트: 엔티티를 영구저장하는 환경
- 엔티티 매니저를 통하여 영컨에 접근 `EntityManager.persist(entity);`
- 스프링 프레임워크 같은 컨테이너 환경은 엔티티매니저와 영컨이 N:1
- 엔티티의 생명주기
    
<img width="746" alt="36" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/99e28e08-f2ca-44a9-ae91-c6da056a751e">

    
- 준영속상태로 만드는 법: em.detech(entity), em.clear(), em.close()

### 영속성 컨텍스트의 이점

- 1차 캐시: 영컨 내부의 캐시. 성능상 이점
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연: 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둠. 트랜잭션을 커밋하면 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화.
- 변경 감지
- 지연 로딩

### 플러시

- 플러시: 영컨의 변경 내용을 디비에 반영, 영컨을 비우는 것이 아님!
- 플러시하는 방법
    - em.flush() - 직접 호출
    - 트랜잭션 커밋 - 자동 호출
    - JPQL 쿼리 실행 - 자동 호출

## 엔티티매핑

### 객체와 테이블 매핑

- **@Entity**: 테이블과 매핑할 클래스에 사용, 기본 생성자 필수
- **@Table**: 엔티티와 매핑할 테이블 지정
    - **name -** 매핑할 테이블 이름, 기본값은 엔티티 이름
    - **schema** - 디비 스키마 매핑

### 데이터베이스 스키마 자동 생성

- **create**: 기존 테이블 삭제 후 다시 생성, 개발 초기
- **create-drop**: create와 같으나 종료 시점에 drop, 개발 초기 혹은 테스트 서버
- **update**: 변경분만 반영, 테스트 서버
- **validate**: 엔티티와 테이블이 정상 매핑되었는지만 확인, 운영 서버
- **none**: 사용x, 운영 서버

### 필드와 컬럼 매핑

- **@Column**: 컬럼 매핑
    - **name** - 필드와 매핑할 테이블의 컬럼명
    - **insertable, updatable** - 등록, 변경 가능 여부
    - **nullable(DDL)** - null 값의 허용 여부 설정, false로 설정하면 DDL 생성시 Not null 제약조건
    - **unique(DDL)** - unique 제약 조건 걸고 싶을때, 랜덤으로 이름을 생성함 이름 반영이 힘들 수 있음
    - **length(DDL)** - 문자 길이 제약조건 String 타입만 가능함
- **@Enumerated**: 자바 enum 타입을 매핑할 때 사용, 웬만하면 STRING 사용. ORDINAL 사용x
- **@Temporal**: 날짜 타입(`java.util.Date`, `java.util.Calendar`)을 매핑할 때 사용
                       LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)
- **@Lob**: 데이터베이스 BLOB, CLOB 타입과 매핑
- **@Transient**: 필드 매핑x, 데이터베이스에 저장x, 조회x, 주로 메모리상에서만 값을 보관하고 싶을 때 사용

### 기본 키 매핑

- **@Id**: PK 매핑
- **@GeneratedValue**: PK 자동 생성
    - **IDENTITY**: 데이터베이스에 위임, MYSQL
        - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행 하고 DB에서 식별자를 조회
    - **SEQUENCE**: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        - @SequenceGenerator 필요
    - **TABLE**: 키 생성용 테이블 사용, 모든 DB에서 사용
        - @TableGenerator 필요
    - **AUTO**: 방언에 따라 자동 지정, 기본값
- 권장하는 식별자 전략: Long형 + 대체키 + 키 생성전략 사용

## 연관관계 매핑 기초

### 단방향 연관관계

- `@JoinColumnn(name = 매핑할 외래키 컬럼명)`
- 한 쪽만 반대쪽은 참조하는 관계

### 양방향 연관관계

- 양 쪽 모두 서로를 참조하는 관계
- 양방향 매핑 규칙: 연관관계의 주인
    - 연관관계의 주인만이 외래 키를 관리
    - 주인이 아니면 `mappedBy` 속성으로 주인 지정
    - 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다
- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐

## 다양한 연관관계 매핑

### N : 1

- 다대일 단방향: 가장 많이 사용하는 연관관계
- 다대일 양방향: 외래 키가 있는 쪽이 연관관계의 주인, 양쪽을 서로 참조하도록 개발

### 1 : N

- 일대다 단방향
    - 일(1)인 쪽이 주인인 동시에 다(N) 쪽에 외래 키가 있음
    - 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
        
        → 그냥 웬만하면 사용하지말자
        
- 일대다 양방향: 공식적으로 존재하진x

### 1 : 1

- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
    - 주 테이블에 외래키
        - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
        - 객체지향 개발자 선호
        - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 
        단점: 값이 없으면 외래 키에 null 허용
    - 대상 테이블에 외래키
        - 대상 테이블에 외래 키가 존재
        - 전통적인 데이터베이스 개발자 선호
        - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 
        단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

### N : M

- 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)하여 1 : N, M : 1의 관계로 풀어가야함
