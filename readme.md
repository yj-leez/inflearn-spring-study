# 자바 ORM 표준 JPA 프로그래밍

## JPA 소개

- JPA: 자바 진영의 ORM 기술 표준
- ORM: 객체는 객체대로 설계하고 관계형 DB는 관계형 DB대로 설계할 수 있게끔 중간에서 객체와 DB의 관계를 매핑해주는 프레임워크
- JPA는 어플리케이션과 JDBC 사이에서 동작한다.
    <img width="699" alt="스크린샷 2023-06-24 오후 7 11 39" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/06723e50-e088-4c29-b5ee-45f3e5ee3caf">


    
- JPA의 성능 최적화 기능
    1. 1차 캐시와 동일성 보장 : 같은 트랜잭션 안에서는 같은 엔티티 반환
    2. 트랜잭션을 지원하는 쓰기 지연
        - INSERT: 트랜잭션을 커밋할 때까지 INSERT SQL을 모은 후 커밋하는 순간 한번에 SQL 전송
        - UPDATE: UPDATE, DELETE로 인한 로우락 시간 최소화위해 커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다.
    3. 지연 로딩(Lazy Loading) : 객체가 실제로 사용될 때 로딩

## JPA시작

- JPA 구동방식
    
<img width="820" alt="스크린샷 2023-06-24 오후 11 19 53" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/f17b5a15-c9ff-49e1-98f9-ee9a63f3fde8">

    

## 영속성 관리

### 영속성 컨텍스트

- 영속성 컨텍스트: 엔티티를 영구저장하는 환경
- 엔티티 매니저를 통하여 영컨에 접근 `EntityManager.persist(entity);`
- 스프링 프레임워크 같은 컨테이너 환경은 엔티티매니저와 영컨이 N:1
- 엔티티의 생명주기
    
<img width="746" alt="36" src="https://github.com/yj-leez/spring-hellojpa/assets/77960090/99e28e08-f2ca-44a9-ae91-c6da056a751e">

    
- 준영속상태로 만드는 법: em.detech(entity), em.clear(), em.close()

### 영속성 컨텍스트의 이점

- 1차 캐시: 영컨 내부의 캐시. 성능상 이점
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연: 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둠. 트랜잭션을 커밋하면 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화.
- 변경 감지
- 지연 로딩

### 플러시

- 플러시: 영컨의 변경 내용을 디비에 반영, 영컨을 비우는 것이 아님!
- 플러시하는 방법
    - em.flush() - 직접 호출
    - 트랜잭션 커밋 - 자동 호출
    - JPQL 쿼리 실행 - 자동 호출

## 엔티티매핑

### 객체와 테이블 매핑

- **@Entity**: 테이블과 매핑할 클래스에 사용, 기본 생성자 필수
- **@Table**: 엔티티와 매핑할 테이블 지정
    - **name -** 매핑할 테이블 이름, 기본값은 엔티티 이름
    - **schema** - 디비 스키마 매핑

### 데이터베이스 스키마 자동 생성

- **create**: 기존 테이블 삭제 후 다시 생성, 개발 초기
- **create-drop**: create와 같으나 종료 시점에 drop, 개발 초기 혹은 테스트 서버
- **update**: 변경분만 반영, 테스트 서버
- **validate**: 엔티티와 테이블이 정상 매핑되었는지만 확인, 운영 서버
- **none**: 사용x, 운영 서버

### 필드와 컬럼 매핑

- **@Column**: 컬럼 매핑
    - **name** - 필드와 매핑할 테이블의 컬럼명
    - **insertable, updatable** - 등록, 변경 가능 여부
    - **nullable(DDL)** - null 값의 허용 여부 설정, false로 설정하면 DDL 생성시 Not null 제약조건
    - **unique(DDL)** - unique 제약 조건 걸고 싶을때, 랜덤으로 이름을 생성함 이름 반영이 힘들 수 있음
    - **length(DDL)** - 문자 길이 제약조건 String 타입만 가능함
- **@Enumerated**: 자바 enum 타입을 매핑할 때 사용, 웬만하면 STRING 사용. ORDINAL 사용x
- **@Temporal**: 날짜 타입(`java.util.Date`, `java.util.Calendar`)을 매핑할 때 사용
                       LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)
- **@Lob**: 데이터베이스 BLOB, CLOB 타입과 매핑
- **@Transient**: 필드 매핑x, 데이터베이스에 저장x, 조회x, 주로 메모리상에서만 값을 보관하고 싶을 때 사용

### 기본 키 매핑

- **@Id**: PK 매핑
- **@GeneratedValue**: PK 자동 생성
    - **IDENTITY**: 데이터베이스에 위임, MYSQL
        - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행 하고 DB에서 식별자를 조회
    - **SEQUENCE**: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        - @SequenceGenerator 필요
    - **TABLE**: 키 생성용 테이블 사용, 모든 DB에서 사용
        - @TableGenerator 필요
    - **AUTO**: 방언에 따라 자동 지정, 기본값
- 권장하는 식별자 전략: Long형 + 대체키 + 키 생성전략 사용

## 연관관계 매핑 기초

### 단방향 연관관계

- `@JoinColumnn(name = 매핑할 외래키 컬럼명)`
- 한 쪽만 반대쪽은 참조하는 관계

### 양방향 연관관계

- 양 쪽 모두 서로를 참조하는 관계
- 양방향 매핑 규칙: 연관관계의 주인
    - 연관관계의 주인만이 외래 키를 관리
    - 주인이 아니면 `mappedBy` 속성으로 주인 지정
    - 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다
- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐

## 다양한 연관관계 매핑

### N : 1

- 다대일 단방향: 가장 많이 사용하는 연관관계
- 다대일 양방향: 외래 키가 있는 쪽이 연관관계의 주인, 양쪽을 서로 참조하도록 개발

### 1 : N

- 일대다 단방향
    - 일(1)인 쪽이 주인인 동시에 다(N) 쪽에 외래 키가 있음
    - 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
        
        → 그냥 웬만하면 사용하지말자
        
- 일대다 양방향: 공식적으로 존재하진x

### 1 : 1

- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
    - 주 테이블에 외래키
        - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
        - 객체지향 개발자 선호
        - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 
        단점: 값이 없으면 외래 키에 null 허용
    - 대상 테이블에 외래키
        - 대상 테이블에 외래 키가 존재
        - 전통적인 데이터베이스 개발자 선호
        - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 
        단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

### N : M

- 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)하여 1 : N, M : 1의 관계로 풀어가야함

## 고급 매핑

### 상속 관계 매핑

- 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
- 각각 테이블로 변환 → 조인전략

    ```java
    @Entity
    @Inheritance(strategy = InheritanceType.JOINED) //조인전략 실행
    @DiscriminatorColumn //테이블에 DTYPE이라는 컬럼 생성
    public class Item {
    /**
    **/
    }
    ```

    ```java
    @Entity
    @DiscriminatorValue("ALBUM") //DTYPE 값으로 어떤 값이 들어갈지 명시
    public class Album extends Item {
    /**
    **/
    }
    ```

    - 장점
        - 테이블을 정규화 시킨 것이다.
        - 외래키 참조 무결성 제약조건 활용 가능
            - Item 테이블의 Id로 다 연결되어 있기 때문에 이를 활용할 수 있다.
            - 예를 들어 movie의 돈을 다 합산한 값을 알고싶으면 Item테이블만 뒤져도 된다.
        - 저장공간 효율화
    - 단점
        - 조회시 조인을 많이 사용하여 성능이 저하된다.
        - 조회 쿼리가 복잡하다.
        - 데이터 저장시 INSERT 쿼리를 2번 호출한다.
- 통합 테이블로 변환 → 단일 테이블 전략
    - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
    - 장점
        - 조인이 필요 없어서 일반적으로 조회 성능이 빠르고 조회 쿼리가 단순함
    - 단점
        - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용
        - 단일테이블에 모든 것을 저장하므로 테이블이 커질 수 있어서 임계점을 넘는 경우 조회 성능이 오히려 느려질 수도
- 서브 타입 테이블로 변환 → 구현 클래스마다 테이블 전략
    - 사용하지말아라

### @MappedSuperClass

- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통 으로 적용하는 정보를 모을 때 사용
- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
- 조회, 검색 불가(em.find(BaseEntity) 불가)

## 프록시와 연관관계 정리

### 지연 로딩

- 지연로딩: 자신과 연관된 엔티티를 실제로 사용할 때 연관된 엔티티를 조회(SELECT)하는 방식
  지연로딩을 하기 위해서는 프록시(proxy)가 필요함
- 즉시로딩: 엔티티를 조회할 때 자신과 연관되는 엔티티를 조인(JOIN)을 통해 함께 조회하는 방식
- 실무에서는 모든 연관관계에 무조건 지연로딩.
- @ManyToOne`(fetch = FetchType.LAZY)`, @ManyToOne과 @OneToOne은 기본이 즉시로딩이므로 LAZY로 설정해야함

### 프록시

- 실제 엔티티 객체 대신 사용되는 객체로서 실제 엔티티 클래스와 상속 관계 및 위임 관계에 있음
- 프록시를 사용하면 엔티티가 사용될 때 까지 조회하지 않고 있다가 필요할 때 조회하는 방식
- `em.getReference()`

### 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들도 싶을 때 사용
- `@OneToMany(`mappedBy="parent", `cascade=CascadeType.PERSIST)`
    - Cascade의 종류: ALL, PERSIST, REMOVE, MERGE, REFRESH, DETACH
- 쓰는 기준
    - Cascade되는 엔티티와 Cascade를 설정하는 엔티티의 라이프사이클이 동일하거나 비슷해야함
    - Cascade되는 엔티티가 Cascade를 설정하는 엔티티에서만 사용되어야함

### 영속성 전이 + 고아 객체, 생명주기

- 고아객체: 부모와 연관관계가 끊어진 엔티티
- `orphanRemoval=true`: 고아객체를 자동으로 삭제해주는 옵션을 활성화
- @OneToOne이나 @OneToMany에 사용 가능
- CascadeType.ALL + orphanRemoval=true
    - 다(N)에 해당하는 리스트 형태의 엔티티는 일(1)에 해당하는 엔티티와 라이프 사이클을 완전히 함께할뿐더러 다른 엔티티에서는 사용되지 않는 엔티티
    - 부모의 엔티티를 통해서 자식 엔티티의 생명주기 관리가 가능
    - 다(N)에 해당하는 엔티티는 리포지토리도 필요가 없음

## 값 타입

- JPA의 데이터 타입은 **엔티티 타입**과 **값 타입**으로 나뉨
- 값 타입은 **기본값 타입**, **임베디드 타입**, **컬렉션 값 타입**으로 분류

### 기본 값 타입

- 종류: 자바 기본 타입(Int, Double), 래퍼 클래스(Integer, Long), String
- 생명주기를 엔티티에 의존
- 절대 공유되면 안 되는 값 - 부수효과가 일어날 수도 있기 때문

### 임베디드 타입

- JPA에서 정의해서 사용해야 하는 값
- 임베디드 타입 사용: `@Embeddable` (값 타입을 정의하는 곳에 표시), `@Embedded` (값 타입을 사용하는 곳에 표시), 기본 생성자 필수
- 장점: 재사용 가능, 높은 응집도
- 한 엔티티 안에서 같은 값 타입을 2개 이상 가지면 컬럼명이 중복됨
  → `@AttributeOverrides`, `@AttributeOverride`를 사용해서 컬러 명 속성을 재정의

### 컬렉션 값 타입

- JPA에서 정의해서 사용해야하는 값
- 컬렉션에 기본값 또는 임베디드 타입을 넣은 형태

### 값 타입과 불변 객체

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함, 부작용 발생
  → 값 타입을 복사하여 사용하자
- 자바 기본 타입에 값을 대입하면 값을 복사하지만 임베디드 같은 객체 타입은 참조를 전달하여 문제
  → 값 타입을 불변 객체로 설계하자
- 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
  생성자로만 값을 설정하고 Setter를 만들지 않으면 됨

### 값 타입의 비교

- 동일성(identity) 비교: 인스턴스의 참조 값을 비교, == 사용
- 동등성(equivalence) 비교: 인스턴스의 값을 비교, equals()